<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <service verb="map" noun="WhTransferOrderFulfillment" transaction-timeout="1800">
        <description>
            Service to map Warehouse to Store Transfer Order Fulfillment from NetSuite in OMS.
            The Warehouse TOs are fulfilled by third party, and so shipments in OMS will be created in Shipped Status.
        </description>
        <in-parameters>
            <parameter name="payload" type="Map" required="true">
                <description>The Transfer Order Fulfillment map from NetSuite to be mapped as per Shipment in OMS.</description>
                <parameter name="transferOrderId"/>
                <parameter name="externalId"/>
                <parameter name="shippedDate"/>
                <parameter name="packages" type="List">
                    <parameter name="packageMap" type="Map">
                        <parameter name="trackingNumber"/>
                        <parameter name="items" type="List">
                            <parameter name="itemMap" type="Map">
                                <parameter name="externalId"/>
                                <parameter name="itemExternalId"/>
                                <parameter name="productIdType"/>
                                <parameter name="productIdValue"/>
                                <parameter name="quantity" type="Integer"/>
                            </parameter>
                        </parameter>
                    </parameter>
                </parameter>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="payload" type="Map">
                <description>The Shipment map with mapped fields for OMS.</description>
                <parameter name="orderId"/>
                <parameter name="externalId"/>
                <parameter name="shipmentStatusId"/>
                <parameter name="shippedDate"/>
                <parameter name="packages" type="List">
                    <parameter name="packageMap" type="Map">
                        <parameter name="trackingNumber"/>
                        <parameter name="items" type="List">
                            <parameter name="itemMap" type="Map">
                                <parameter name="orderItemSeqId"/>
                                <parameter name="externalId"/>
                                <parameter name="productId"/>
                                <parameter name="quantity" type="Integer"/>
                            </parameter>
                        </parameter>
                    </parameter>
                </parameter>
            </parameter>
        </out-parameters>
        <actions>
            <!-- By default, external fulfilled shipments for WH TOs will be created in SHIPMENT_SHIPPED status -->
            <set field="payload.shipmentStatusId" value="SHIPMENT_SHIPPED"/>

            <!-- Get HC Order ID -->
            <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                <econdition field-name="idValue" from="payload.remove('transferOrderId')"/>
                <econdition field-name="orderIdentificationTypeId" value="NETSUITE_ORDER_ID"/>
                <date-filter/>
            </entity-find>
            <set field="payload.orderId" from="orderIdentificationList?.first?.orderId"/>
            <iterate list="payload.packages" entry="shipmentPackage">
                <!-- Create a list to track items that should be kept -->
                <set field="validItems" from="[]"/>

                <iterate list="shipmentPackage.items" entry="item">
                    <!-- Get HC Product ID -->
                    <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentifications" limit="1">
                        <econdition field-name="goodIdentificationTypeId" from="item.remove('productIdType')"/>
                        <econdition field-name="idValue" from="item.remove('productIdValue')"/>
                        <date-filter/>
                        <order-by field-name="-fromDate"/>
                    </entity-find>
                    <set field="item.productId" from="goodIdentifications?.first?.productId"/>

                    <!-- Get Order Item Seq ID and Ship Group Seq ID and check status -->
                    <entity-find entity-name="org.apache.ofbiz.order.order.OrderItem" list="orderItemList">
                        <econdition field-name="orderId" from="payload.orderId"/>
                        <econdition field-name="externalId" from="item.remove('itemExternalId')"/>
                    </entity-find>
                    <set field="item.orderItemSeqId" from="orderItemList?.first?.orderItemSeqId"/>
                    <set field="orderItemStatusId" from="orderItemList?.first?.statusId"/>

                    <!-- Only add item to validItems if it's not completed -->
                    <if condition="orderItemStatusId != 'ITEM_COMPLETED'">
                        <script>validItems.add(item)</script>
                        <else>
                            <!-- Log that we're skipping a completed item -->
                            <log level="info" message="OrderItem [${item.orderItemSeqId}] for Order [${payload.orderId}] – skipped in shipment creation; already completed."/>
                        </else>
                    </if>
                </iterate>

                <!-- Replace the items list with only valid items -->
                <set field="shipmentPackage.items" from="validItems"/>
            </iterate>

            <!-- Remove packages that have no valid items -->
            <set field="validPackages" from="[]"/>
            <iterate list="payload.packages" entry="shipmentPackage">
                <if condition="shipmentPackage.items">
                    <script>validPackages.add(shipmentPackage)</script>
                </if>
            </iterate>
            <set field="payload.packages" from="validPackages"/>

            <!-- If no packages remain with valid items, return empty payload to skip shipment creation -->
            <if condition="!payload.packages">
                <log level="info" message="Shipment [${payload.externalId}] – skipped for creation; all items already completed."/>
                <set field="payload" from="[:]"/>
            </if>
        </actions>
    </service>

    <!-- NOTE: Removed the support of productStoreId for now, TODO need to check in future for multi store setup -->
    <service verb="generate" noun="TransferOrderShipmentReceiptFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <in-parameters>
            <parameter name="shipmentId">
                <description>Parameter to fetch Shipment details for a specific shipmentId.</description>
            </parameter>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote ID to send Shipment Receipt Feed.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating Shipment Receipt Feed.</description>
            </parameter>
            <parameter name="sinceReceivedDate">
                <description>Parameter to fetch Shipment Receipt details received after a specific date.</description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>
            <log message="Generating Transfer Order Shipments Receipt Feed file for Shipment ${shipmentId} at time ${nowTimestamp}"/>

            <!-- Fetch the SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime for creating feeds.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
                import org.moqui.entity.EntityCondition

                toShipmentReceipt_find = ec.entity.find("co.hotwax.netsuite.TransferOrderShipmentReceiptHistory")

                if(shipmentId) toShipmentReceipt_find.condition("shipmentId", shipmentId)
                if(sinceReceivedDate) toShipmentReceipt_find.havingCondition(ec.entity.conditionFactory.makeCondition("receivedDate", EntityCondition.ComparisonOperator.GREATER_THAN, sinceReceivedDate))
                toShipmentReceipt_find.selectField("shipmentId,shipmentExternalId,orderId")
                toShipmentReceipt_find.distinct(true)

                //If no eligible receipts, then don't generate the file
                long shipmentReceiptCount = toShipmentReceipt_find.count()
                if (shipmentReceiptCount == 0) {
                    ec.message.addMessage("No eligible Shipment Receipt for TO Shipment Receipt Feed at ${nowTimestamp}, not generating the TO Shipment Receipt Feed File for NetSuite.")
                    return
                }

                // Using try-with-resources to automatically close the EntityListIterator 'toShipmentReceiptItr'
                try (toShipmentReceiptItr = toShipmentReceipt_find.iterator()) {
            </script>

            <!-- Prepare TO Shipment Receipt JSON File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd'),
                dateTime:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Prepare the TO Shipment Receipt Feed file -->
            <script>
                try {
                    //json file
                    File toShipmentReceiptFeedFile = new File(jsonFilePath)
                    if (!toShipmentReceiptFeedFile.parentFile.exists()) toShipmentReceiptFeedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, toShipmentReceiptFeedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <!-- Preparing Shipment Receipts -->
            <iterate list="toShipmentReceiptItr" entry="toShipmentReceipt">
                <!-- Get NetSuite Order ID -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="toShipmentReceipt.orderId"/>
                    <econdition field-name="orderIdentificationTypeId" value="NETSUITE_ORDER_ID"/>
                    <date-filter/>
                </entity-find>

                <!-- Set Shipment Receipt level details -->
                <set field="shipmentReceiptMap" from="[shipmentId:toShipmentReceipt.shipmentId,
                    fulfillmentId:toShipmentReceipt.shipmentExternalId, orderId:orderIdentificationList?.first?.idValue]"/>
                <set field="items" from="[]"/>

                <!-- Get Shipment Receipt Item level details for the Shipment -->
                <entity-find entity-name="co.hotwax.netsuite.TransferOrderShipmentReceiptHistory" list="shipmentReceiptItems">
                    <econdition field-name="shipmentId" from="toShipmentReceipt.shipmentId"/>
                    <select-field field-name="shipmentItemExternalId,productId,shipmentItemSeqId,totalQuantityAccepted"/>
                </entity-find>

                <!-- Preparing Shipment Receipt Item Details -->
                <iterate list="shipmentReceiptItems" entry="shipmentReceiptItem">
                    <!-- Get NetSuite Product ID for each item -->
                    <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                        <econdition field-name="productId" from="shipmentReceiptItem.productId"/>
                        <econdition field-name="goodIdentificationTypeId" value="NETSUITE_PRODUCT_ID"/>
                        <date-filter/>
                    </entity-find>

                    <!-- Set Shipment Receipt Item level details -->
                    <set field="shipmentReceiptItemMap" from="[lineId:shipmentReceiptItem.shipmentItemExternalId,
                        quantity:shipmentReceiptItem.totalQuantityAccepted, productId:goodIdentificationList?.first?.idValue]"/>
                    <script>items.add(shipmentReceiptItemMap)</script>

                    <!-- NOTE The quantity sent for an item received will be the totalQuantityAccepted for the item per Shipment.
                        Eg. A TO Item is fulfilled as part of Shipment S1 with quantity 10, and receipts were created at item
                        level with quantity 6 and 4, the ShipmentReceipt will have 2 records with the same shipment.
                        If in NetSuite, this is sent as-is, it only records the quantity of the last record in the file for a
                        lineId, so only 4 quantity will get received and 6 quantity will be ignored.
                        So we are sending the totalQuantityAccepted per item per Shipment, but to create the history for the
                        receipts, we need to fetch the receiptIds of the ShipmentItem. -->
                    <entity-find entity-name="co.hotwax.netsuite.TransferOrderShipmentReceiptHistory" list="shipmentReceiptItemsForHistory">
                        <econdition field-name="shipmentId" from="toShipmentReceipt.shipmentId"/>
                        <econdition field-name="shipmentItemSeqId" from="shipmentReceiptItem.shipmentItemSeqId"/>
                        <select-field field-name="receiptId"/>
                    </entity-find>

                    <!-- Create Shipment Receipt History for each received item included in the feed -->
                    <iterate list="shipmentReceiptItemsForHistory" entry="shipmentReceiptItemForHistory">
                        <service-call name="create#co.hotwax.integration.shipment.ShipmentReceiptHistory"
                                in-map="[receiptId:shipmentReceiptItemForHistory.receiptId, createdDate:nowTimestamp,
                                comments:'Shipment Receipt Item sent as part of Transfer Order Shipment Receipt Feed']"/>
                    </iterate>
                </iterate>
                <set field="shipmentReceiptMap.items" from="items"/>

                <script>
                    new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, shipmentReceiptMap)
                </script>
            </iterate>
            <script>
                            jGenerator.writeEndArray()
                        }
                    } catch (IOException e) {
                        logger.info("Error preparing transfer order shipment receipt Feed file", e)
                    }
                }
            </script>

            <!-- Call queue#SystemMessage that will save the json file path in messageText and
            send the file to sftp using send service configured in SystemMessageType -->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                messageText:jsonFilePathRef]" out-map="shipmentsReceiptFeedSysMsgOut"/>

            <return message="Completed the Transfer Order Shipment Receipt Feed file at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${shipmentsReceiptFeedSysMsgOut?.systemMessageId}"/>
        </actions>
    </service>

    <service verb="map" noun="TransferOrder" transaction-timeout="1800">
        <in-parameters>
            <parameter name="payload" type="Map" required="true">
                <description>The order map from NetSuite to be mapped as per OMS.</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="payload" type="Map">
                <description>The order map with mapped fields for OMS.</description>
            </parameter>
        </out-parameters>
        <actions>
            <!-- Set Order Header level fields  -->
            <set field="payload.entryDate" from="ec.user.nowTimestamp"/>
            <set field="payload.identifications*.fromDate" from="ec.user.nowTimestamp"/>
            <set field="payload.statuses" from="[statusId:'ORDER_CREATED', statusDatetime:ec.user.nowTimestamp,
                statusUserLogin:ec.user.getUsername()]"/>

            <!-- Get HC Facility ID for both origin and destination Facility of TO  -->
            <set field="externalFacilityIdList" from="[payload.remove('originFacilityExternalId'), payload.shipGroups[0].remove('orderFacilityExternalId')]"/>
            <entity-find entity-name="org.apache.ofbiz.product.facility.Facility" list="facilityList" cache="true">
                <econdition field-name="externalId" operator="in" from="externalFacilityIdList"/>
            </entity-find>

            <!-- use filed-map-list to filter the facilityList based on the externalFacilityIdList-->
            <filter-map-list list="facilityList" to-list="originFacilities">
                <field-map field-name="externalId" from="externalFacilityIdList[0]"/>
            </filter-map-list>

            <filter-map-list list="facilityList" to-list="orderFacilities">
                <field-map field-name="externalId" from="externalFacilityIdList[1]"/>
            </filter-map-list>

            <!-- Set HC Facility Ids  -->
            <set field="payload.shipGroups[0].facilityId" from="originFacilities[0]?.facilityId"/>
            <set field="payload.originFacilityId" from="originFacilities[0]?.facilityId"/>
            <set field="payload.shipGroups[0].orderFacilityId" from="orderFacilities[0]?.facilityId"/>

            <!-- Get RECEIVE_BY_FULFILL setting to determine maySplit flag -->
            <entity-find-one entity-name="org.apache.ofbiz.product.store.ProductStoreSetting" value-field="receiveByFulfillSetting">
                <field-map field-name="productStoreId" from="payload.productStoreId"/>
                <field-map field-name="settingTypeEnumId" value="RECEIVE_BY_FULFILL"/>
            </entity-find-one>

            <!-- Set maySplit based on RECEIVE_BY_FULFILL setting (null or false = true, true = false) -->
            <!-- When RECEIVE_BY_FULFILL is ON (true), maySplit should be false (no split shipments) -->
            <!-- When RECEIVE_BY_FULFILL is OFF or null (false), maySplit should be true (allow split shipments) -->
            <set field="receiveByFulfillEnabled" from="receiveByFulfillSetting?.settingValue?.toLowerCase() == 'true'"/>
            <set field="payload.shipGroups[0].maySplit" from="receiveByFulfillEnabled ? 'N' : 'Y'"/>


            <!-- Get HC Product ID for TO items  -->
            <iterate list="payload.shipGroups[0].items" entry="item">

                <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentifications" limit="1">
                    <econdition field-name="goodIdentificationTypeId" from="item.remove('productIdType')"/>
                    <econdition field-name="idValue" from="item.remove('productIdValue')"/>
                    <date-filter/>
                    <order-by field-name="-fromDate"/>
                </entity-find>

                <!-- Set Order Item level fields  -->
                <set field="item.productId" from="goodIdentifications?.first?.productId"/>
                <set field="item.statuses" from="[statusId:'ITEM_CREATED', statusDatetime:ec.user.nowTimestamp,
                    statusUserLogin:ec.user.getUsername()]"/>
            </iterate>
        </actions>
    </service>

    <!-- NOTE: Removed the support of productStoreId for now, TODO need to check in future for multi store setup -->
    <service verb="generate" noun="TransferOrderShipmentFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Service to generate Transfer Order Shipment Feed.
            The Feed will be Shipment wise and each Shipment containing the list of Shipment Items.
        </description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote ID for generating the Transfer Order Shipment Feed.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the Transfer Order Shipment Feed.</description>
            </parameter>
            <parameter name="orderId">
                <description>Parameter to fetch the Transfer Order Shipment details for a specific orderId.</description>
            </parameter>
            <parameter name="orderItemSeqId">
                <description>Parameter to fetch Transfer Order Shipment item details for a specific orderItemSeqId.</description>
            </parameter>
            <parameter name="parentFacilityTypeIds" type="List">
                <description>
                    List of parent Facility Type Ids for generating Transfer Order Shipment Feed.
                    For passing the parent Facility Type Ids as list, add values like - PHYSICAL_STORE,DISTRIBUTION_CENTER,VIRTUAL_FACILITY and for single value use - PHYSICAL_STORE.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>
            <log message="Generating Transfer Order Shipment Feed file of HotWax for Order ${orderId}, at time ${nowTimestamp}"/>

            <!-- Fetch the SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime for creating feeds.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
                import org.moqui.entity.EntityCondition

                transferOrderShipment_find = ec.entity.find("co.hotwax.netsuite.TransferOrderShipmentItemHistory")
                transferOrderShipment_find.condition("statusId", "SHIPMENT_SHIPPED")

                if(orderId) transferOrderShipment_find.condition("orderId", orderId)
                if(orderItemSeqId) transferOrderShipment_find.condition("orderItemSeqId", orderItemSeqId)
                if(parentFacilityTypeIds) transferOrderShipment_find.condition("parentFacilityTypeId",EntityCondition.ComparisonOperator.IN, parentFacilityTypeIds)
                transferOrderShipment_find.selectField("shipmentId,orderId,trackingIdNumber")
                transferOrderShipment_find.distinct(true)

                //If no eligible shipments, then don't generate the file
                long shipmentCount = transferOrderShipment_find.count()
                if (shipmentCount == 0) {
                    ec.message.addMessage("No eligible orders for Transfer Order Shipment Feed at ${nowTimestamp}, not generating the TO Shipment Feed File for NetSuite.")
                    return
                }

                // Using try-with-resources to automatically close the EntityListIterator 'transferOrderShipmentItr'
                try (transferOrderShipmentItr = transferOrderShipment_find.iterator()) {
            </script>

            <!-- Prepare Transfer Order Shipment Feed JSON File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd'),
                dateTime:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>

            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Prepare the Transfer Order Shipment Feed file  -->
            <script>
                    try {
                        //json file
                        File transferOrderShipmentFeedFile = new File(jsonFilePath)
                        if (!transferOrderShipmentFeedFile.parentFile.exists()) transferOrderShipmentFeedFile.parentFile.mkdirs()
                        JsonFactory jfactory = new JsonFactory()

                        /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                        try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, transferOrderShipmentFeedFile);
                            JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                                jGenerator.writeStartArray()
            </script>

            <!-- Get Shipment Items -->
            <iterate list="transferOrderShipmentItr" entry="transferOrderShipment">
                <!-- Get NetSuite Order ID -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="transferOrderShipment.orderId"/>
                    <econdition field-name="orderIdentificationTypeId" value="NETSUITE_ORDER_ID"/>
                    <date-filter/>
                </entity-find>

                <!-- Set Shipment level details -->
                <set field="shipmentMap" from="[orderId:orderIdentificationList?.first?.idValue,
                    trackingNumber:transferOrderShipment.trackingIdNumber, shipmentId:transferOrderShipment.shipmentId]"/>
                <set field="items" from="[]"/>

                <entity-find entity-name="co.hotwax.netsuite.TransferOrderShipmentItemHistory" list="shipmentItems">
                    <econdition field-name="shipmentId" from="transferOrderShipment.shipmentId"/>
                </entity-find>

                <iterate list="shipmentItems" entry="shipmentItem">
                    <!-- Get NetSuite Item Line ID -->
                    <entity-find entity-name="org.apache.ofbiz.order.order.OrderItemAttribute" list="orderItemAttrList">
                        <econdition field-name="orderId" from="transferOrderShipment.orderId"/>
                        <econdition field-name="orderItemSeqId" from="shipmentItem.orderItemSeqId"/>
                        <econdition field-name="attrName" value="NetsuiteItemLineId"/>
                    </entity-find>

                    <!-- Set Shipment Item level details -->
                    <set field="shipmentItemMap" from="[shipmentItemSeqId:shipmentItem.shipmentItemSeqId, lineId:orderItemAttrList?.first?.attrValue, quantity:shipmentItem.quantity, tags:'hotwax-fulfilled']"/>
                    <script>items.add(shipmentItemMap)</script>

                    <!-- Create Order Fulfillment History record for each shipment item included in the feed -->
                    <service-call name="create#co.hotwax.integration.order.OrderFulfillmentHistory"
                            in-map="[orderId:shipmentItem.orderId, orderItemSeqId:shipmentItem.orderItemSeqId,
                            shipmentId:shipmentItem.shipmentId, externalFulfillmentId:'_NA_',
                            comments:'Shipment Item sent as part of Transfer Order Shipment Feed', createdDate:nowTimestamp]"/>
                </iterate>
                <set field="shipmentMap.items" from="items"/>

                <script>
                    new ObjectMapper()
                    .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                    .writerWithDefaultPrettyPrinter().writeValue(jGenerator, shipmentMap)
                </script>
            </iterate>
            <script>
                            jGenerator.writeEndArray()
                        }
                    }
                    catch (IOException e) {
                        logger.info("Error preparing transfer order shipment Feed file", e)
                    }
                }
            </script>

            <!-- Save the Json Feed File path in System Message messageText -->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                messageText:jsonFilePathRef]" out-map="shipmentFeedSysMsgOut"/>

            <return message="Completed Transfer Order Shipment Feed file at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${shipmentFeedSysMsgOut?.systemMessageId}"/>
        </actions>
    </service>

    <service verb="generate" noun="TransferOrderSyncAckFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>Service to generate feed file for NetSuite to acknowledge the Transfer Order is created successfully in OMS</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="filePathPattern" required="true" default-value="netsuite/transferorderv2/update"/>
            <parameter name="orderId"/>
            <parameter name="sinceEntryDate">
                <description>Parameter to fetch Order details after specific entryDate of OrderHeader.</description>
            </parameter>
            <parameter name="recordLimitPerFeed" type="Integer" default-value="1000"/>
            <parameter name="jobName">
                <description>The name of the scheduled job to fetch the last run time for preparing the Feed.</description>
            </parameter>
            <parameter name="skipLastRunTimeUpdate" type="Boolean" default="false">
                <description>skip the LastRunTime update,mainly used while debugging</description>
            </parameter>
        </in-parameters>
        <actions>
            <log message="Generating Transfer Order Sync Ack Feed file at time ${nowTimestamp}"/>

            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>
            <set field="baseFile" value="runtime://datamanager/${filePathPattern}/TransferOrderSyncAckFeed_${ec.l10n.format(nowTimestamp, 'yyyy-MM-dd-HH-mm-ss-SSS')}.csv"/>
            <set field="baseFilePath" from="ec.resource.getLocationReference(baseFile).getUri().getPath()"/>
            <set field="sendPath" from="'/home/${sftpUsername}/' + filePathPattern + '/'"/>

            <!-- We can use last run time to fetch the records updated after the last service job run -->
            <!-- Check the parameter used for storing the last feed run time -->
            <entity-find-one entity-name="moqui.service.job.ServiceJobParameter" value-field="lastRunParam">
                <field-map field-name="jobName"/>
                <field-map field-name="parameterName" value="lastRunTime"/>
            </entity-find-one>

            <!-- Set sinceEntryDate using the lastRunTime, if it is set, fetch records from
                   that time, else it will be null -->
            <if condition="!sinceEntryDate">
                <set field="sinceEntryDate" from="lastRunParam?.parameterValue"/>
            </if>

            <script>
                import co.hotwax.ns.util.CsvWriteHelper
                import org.moqui.entity.EntityCondition

                orderHeaderFind = ec.entity.find("co.hotwax.netsuite.TransferOrderWithIdentification")
                if(orderId) orderHeaderFind.condition("hotwaxOrderId", orderId)
                if(sinceEntryDate) orderHeaderFind.condition("entryDate", EntityCondition.ComparisonOperator.GREATER_THAN, sinceEntryDate)
                .orderBy("entryDate")

                //If no eligible orders, then don't generate the file
                long transferOrdersCount = orderHeaderFind.count()
                if (transferOrdersCount == 0) {
                    ec.message.addMessage("No eligible transfer orders for Feed at ${nowTimestamp}, not generating the HotWax Feed file.")
                    return
                }
                try (orderHeaderItr = orderHeaderFind.iterator();
                CsvWriteHelper csvWriteHelper = new CsvWriteHelper(baseFilePath, null, recordLimitPerFeed)) {
            </script>
            <iterate list="orderHeaderItr" entry="order">
                <script>csvWriteHelper.writeToFile([internalId:order.idValue, hcOrderId:order.hotwaxOrderId])</script>
            </iterate>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="systemMessageRemote"/>
            <set field="generatedFilePaths" from="csvWriteHelper.getGeneratedFilePaths()"/>
            <script>}</script>
            
            <iterate list="generatedFilePaths" entry="generatedFilePath">
                <service-call name="co.hotwax.helper.HelperServices.put#FileOnSftp" in-map="[systemMessageRemoteId:systemMessageRemote.systemMessageRemoteId, receivePath:generatedFilePath, sendPath:sendPath]"/>
            </iterate>
            
            <if condition="!skipLastRunTimeUpdate">
                <!-- Set the current timestamp as the last run time for next run -->
                <service-call name="update#moqui.service.job.ServiceJobParameter"
                    in-map="[jobName:lastRunParam.jobName, parameterName:lastRunParam.parameterName, parameterValue:nowTimestamp]"/>
            </if>
            
            <return message="Created the Transfer Order Sync Ack Feed file at time ${nowTimestamp} saved response in messages ${generatedFilePaths}"/>
        </actions>
    </service>
    <service verb="generate" noun="CompletedTransferOrderItemsFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>Service to generate feed file for NetSuite to close Transfer Order items</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="filePathPattern" required="true" default-value="netsuite/transferorderv2/update"/>
            <parameter name="orderId">
                <description>Optional parameter to process a specific transfer order</description>
            </parameter>
            <parameter name="completedDate">
                <description>Parameter to fetch Order details after specific completed date of Transfer Order</description>
            </parameter>
            <parameter name="recordLimitPerFeed" type="Integer" default-value="1000"/>
            <parameter name="jobName">
                <description>The name of the scheduled job to fetch the last run time for preparing the Feed</description>
            </parameter>
            <parameter name="skipLastRunTimeUpdate" type="Boolean" default="false">
                <description>Skip the LastRunTime update, mainly used while debugging</description>
            </parameter>
        </in-parameters>
        <actions>
            <log message="Generating Completed Transfer Order Item Feed file at time ${nowTimestamp}"/>

            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>
            <set field="baseFile" value="runtime://datamanager/${filePathPattern}/TransferOrderItemClosureFeed_${ec.l10n.format(nowTimestamp, 'yyyy-MM-dd-HH-mm-ss-SSS')}.csv"/>
            <set field="baseFilePath" from="ec.resource.getLocationReference(baseFile).getUri().getPath()"/>
            <set field="sendPath" from="'/home/${sftpUsername}/' + filePathPattern + '/'"/>

            <!-- Get the last run time to fetch records updated after the last job run -->
            <entity-find-one entity-name="moqui.service.job.ServiceJobParameter" value-field="lastRunParam">
                <field-map field-name="jobName"/>
                <field-map field-name="parameterName" value="lastRunTime"/>
            </entity-find-one>

            <!-- Set completedDate using the lastRunTime if not explicitly provided -->
            <if condition="!completedDate">
                <set field="completedDate" from="lastRunParam?.parameterValue"/>
            </if>

            <script>
                import co.hotwax.ns.util.CsvWriteHelper
                import org.moqui.entity.EntityCondition

                // Query to find transfer order items that need to be closed
                toItemFind = ec.entity.find("co.hotwax.netsuite.CompletedTransferOrderItem")

                if (orderId) {
                    toItemFind.condition("orderId", orderId)
                }
                if (completedDate) {
                    toItemFind.condition("statusDatetime", EntityCondition.ComparisonOperator.GREATER_THAN, completedDate)
                }

                toItemFind.selectField("orderId,itemExternalId,netsuiteOrderId")

                // If no eligible order items, don't generate the file
                long toItemsCount = toItemFind.count()
                if (toItemsCount == 0) {
                    ec.message.addMessage("No eligible transfer order items found for closure at ${nowTimestamp}, not generating the feed file.")
                    return
                }

                try (toItemItr = toItemFind.iterator();
                CsvWriteHelper csvWriteHelper = new CsvWriteHelper(baseFilePath, ["internalId", "hcOrderId", "lineId", "hcClosed"], recordLimitPerFeed)) {
            </script>

            <iterate list="toItemItr" entry="toItem">
                <script>
                    // Write the order item details to CSV with isClosed as TRUE
                    csvWriteHelper.writeToFile([internalId: toItem.netsuiteOrderId, hcOrderId: toItem.orderId, lineId: toItem.itemExternalId, hcClosed: "TRUE"])
                </script>
            </iterate>

            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="systemMessageRemote">
                <field-map field-name="systemMessageRemoteId" from="systemMessageRemoteId"/>
            </entity-find-one>

            <set field="generatedFilePaths" from="csvWriteHelper.getGeneratedFilePaths()"/>
            <script>}</script>

            <!-- Upload generated files to SFTP -->
            <iterate list="generatedFilePaths" entry="generatedFilePath">
                <service-call name="co.hotwax.helper.HelperServices.put#FileOnSftp" in-map="[systemMessageRemoteId:systemMessageRemote.systemMessageRemoteId, receivePath:generatedFilePath, sendPath:sendPath]"/>
            </iterate>

            <!-- Update the last run time if not skipped -->
            <if condition="!skipLastRunTimeUpdate">
                <service-call name="update#moqui.service.job.ServiceJobParameter" in-map="[jobName:jobName, parameterName:'lastRunTime', parameterValue:nowTimestamp]"/>
            </if>
            <return message="Created Transfer Order Item Closure Feed file at time ${nowTimestamp} with ${toItemsCount} items. Files: ${generatedFilePaths}"/>
        </actions>
    </service>

    <service verb="generate" noun="TransferOrderMisShippedReceiptAdjFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>Service to generate the Inventory Adjustment file for NetSuite for the Transfer Order receipts for products which were mis-shipped as part of the order.</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="filePathPattern" required="true" default-value="netsuite/inventoryadjustment"/>
            <parameter name="adjustmentAccount" required="true">
                <description>
                    The specific General Ledger (GL) account where the financial impact of inventory changes is recorded when you use an Inventory Adjustment transaction in NetSuite.
                </description>
            </parameter>
            <parameter name="sinceDatetimeReceived">
                <description>Parameter to fetch Transfer Order Receipts as inventory adjustment after a specific datetimeReceived.</description>
            </parameter>
            <parameter name="orderId">
                <description>
                    The Transfer Order ID in OMS to sync the mis-shipped receipts as inventory adjustment, if required.
                </description>
            </parameter>
            <parameter name="recordLimitPerFeed" type="Integer" default-value="1000"/>
            <parameter name="jobName">
                <description>The name of the scheduled job to fetch the last run time for preparing the Feed.</description>
            </parameter>
            <parameter name="skipLastRunTimeUpdate" type="Boolean" default="false">
                <description>skip the LastRunTime update,mainly used while debugging</description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>
            <log message="Generating Transfer Order Inventory Adjustment Feed file for mis-shipped receipts at time ${nowTimestamp}"/>

            <set field="baseFile" value="runtime://datamanager/${filePathPattern}/TransferOrderMisShippedReceiptInvAdjFeed_${ec.l10n.format(nowTimestamp, 'yyyy-MM-dd-HH-mm-ss-SSS')}.csv"/>
            <set field="baseFilePath" from="ec.resource.getLocationReference(baseFile).getUri().getPath()"/>
            <set field="sendPath" from="'/home/${sftpUsername}/' + filePathPattern + '/'"/>

            <!-- We can use last run time to fetch the records updated after the last service job run -->
            <!-- Check the parameter used for storing the last feed run time -->
            <entity-find-one entity-name="moqui.service.job.ServiceJobParameter" value-field="lastRunParam">
                <field-map field-name="jobName"/>
                <field-map field-name="parameterName" value="lastRunTime"/>
            </entity-find-one>

            <!-- Set sinceDatetimeReceived using the lastRunTime, if it is set, fetch records from
                   that time, else it will be null -->
            <if condition="!sinceDatetimeReceived">
                <set field="sinceDatetimeReceived" from="lastRunParam?.parameterValue"/>
            </if>

            <script>
                import co.hotwax.ns.util.CsvWriteHelper
                import org.moqui.entity.EntityCondition

                toMisShippedReceiptFind = ec.entity.find("co.hotwax.netsuite.TransferOrderMisShippedReceipt")
                if (orderId) toMisShippedReceiptFind.condition("orderId", orderId)
                if( sinceDatetimeReceived) toMisShippedReceiptFind.condition("datetimeReceived", EntityCondition.ComparisonOperator.GREATER_THAN, sinceDatetimeReceived)
                .orderBy("datetimeReceived")

                //If no eligible receipts, then don't generate the file
                long toMisShippedReceiptCount = toMisShippedReceiptFind.count()
                if (toMisShippedReceiptCount == 0) {
                    ec.message.addMessage("No eligible Transfer Order Mis-Shipped Receipts for Feed at ${nowTimestamp}, not generating the HotWax Feed file.")
                    return
                }
                try (toMisShippedReceiptItr = toMisShippedReceiptFind.iterator();
                CsvWriteHelper csvWriteHelper = new CsvWriteHelper(baseFilePath, null, recordLimitPerFeed)) {
            </script>
            <iterate list="toMisShippedReceiptItr" entry="toReceipt">

                <!-- Get NetSuite Product ID for the item received -->
                <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                    <econdition field-name="productId" from="toReceipt.productId"/>
                    <econdition field-name="goodIdentificationTypeId" value="NETSUITE_PRODUCT_ID"/>
                    <date-filter/>
                </entity-find>

                <!-- Get the Receiving Facility External Id and Name,
                     NOTE: not adding this in view for potential issue of duplicate records since no order item available
                        and so join would have to be added on OISG from OH. -->
                <entity-find entity-name="co.hotwax.oms.order.TransferOrderAndItem" list="transferOrderList" limit="1">
                    <econdition field-name="orderId" from="toReceipt.orderId"/>
                    <select-field field-name="orderId,orderFacilityExternalId,orderFacilityName"/>
                </entity-find>

                <set field="invAdjMap" from="['Reference No':toReceipt.orderName + '-' + toReceipt.receiptId,
                        'Adjustment Account':adjustmentAccount,
                        Item:goodIdentificationList?.first?.idValue,
                        'Adjust Qty By':toReceipt.quantityAccepted,
                        'Date': ec.l10n.format(nowTimestamp, 'MM/dd/yyyy'),
                        Memo:'Inventory Adj for MisShipped Item Receipt for Transfer Order ' +  toReceipt.orderName,
                        'HC Inventory Adj Id':toReceipt.orderId,
                        Location:transferOrderList?.first?.orderFacilityExternalId,
                        'Adjustment Location':transferOrderList?.first?.orderFacilityExternalId,
                        'Facility Name':transferOrderList?.first?.orderFacilityName,]"/>
                <script>csvWriteHelper.writeToFile(invAdjMap)</script>
            </iterate>
            <set field="generatedFilePaths" from="csvWriteHelper.getGeneratedFilePaths()"/>
            <script>}</script>

            <iterate list="generatedFilePaths" entry="generatedFilePath">
                <service-call name="co.hotwax.helper.HelperServices.put#FileOnSftp" in-map="[systemMessageRemoteId:systemMessageRemoteId, receivePath:generatedFilePath, sendPath:sendPath]"/>
            </iterate>

            <if condition="!skipLastRunTimeUpdate">
                <!-- Set the current timestamp as the last run time for next run -->
                <service-call name="update#moqui.service.job.ServiceJobParameter"
                    in-map="[jobName:lastRunParam.jobName, parameterName:lastRunParam.parameterName, parameterValue:nowTimestamp]"/>
            </if>

            <return message="Created the Transfer Order Inventory Adjustment Feed file for mis-shipped receipts feed file at time ${nowTimestamp} saved response in messages ${generatedFilePaths}"/>
        </actions>
    </service>

    <service verb="generate" noun="TransferOrderReconciliationFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Generate Feed file for reconciliation of the completed Transfer Orders.
            This will include details for overReceivedItems and underReceivedShipments for each completed order.
            For the items which are not shipped but received, they will be included in overReceivedItems for inventory adjustment.
            This feed is expected to work with the history entity, TransferOrderItemAndHistory.
        </description>
        <in-parameters>
            <parameter name="orderId">
                <description>Parameter to fetch reconciliation details for a specific orderId.</description>
            </parameter>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote ID to send Transfer Order Reconciliation Feed.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating Transfer Order Reconciliation Feed.</description>
            </parameter>
            <parameter name="sinceCompletedDate">
                <description>Parameter to fetch Transfer Order Reconciliation details for items completed after a specific date.</description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>
            <log message="Generating Transfer Order Reconciliation Feed file for orderId ${orderId} at time ${nowTimestamp}"/>

            <!-- Fetch the SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime for creating feeds.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
                import org.moqui.entity.EntityCondition

                transferOrder_find = ec.entity.find("co.hotwax.netsuite.TransferOrderItemAndHistory")

                if(orderId) transferOrder_find.condition("orderId", orderId)
                if(sinceCompletedDate) transferOrder_find.condition("statusDatetime", EntityCondition.ComparisonOperator.GREATER_THAN, sinceCompletedDate)
                transferOrder_find.selectField("orderId,orderName,nsOrderId,orderFacilityExternalId")
                transferOrder_find.distinct(true)

                //If no eligible transfer orders, then don't generate the file
                long transferOrderCount = transferOrder_find.count()
                if (transferOrderCount == 0) {
                    ec.message.addMessage("No eligible Transfer Orders for Receipt Reconciliation Feed at ${nowTimestamp}, not generating the Feed File for NetSuite.")
                    return
                }

                // Using try-with-resources to automatically close the EntityListIterator
                try (transferOrderItr = transferOrder_find.iterator()) {
            </script>

            <!-- Prepare TO Receipt Reconciliation JSON File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd'),
                dateTime:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <set field="isFileEmpty" from="true"/>
            <!-- Prepare the Transfer Order Reconciliation Feed file -->
            <script>
                try {
                    //json file
                    File toReconciliationFeedFile = new File(jsonFilePath)
                    if (!toReconciliationFeedFile.parentFile.exists()) toReconciliationFeedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, toReconciliationFeedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <!-- Preparing Transfer Orders Receipt details -->
            <iterate list="transferOrderItr" entry="transferOrder">
                <!-- Set Transfer Order level details -->
                <set field="transferOrderMap" from="[hcOrderId:transferOrder.orderId, orderName:transferOrder.orderName,
                    transferOrderId:transferOrder.nsOrderId, destinationFacilityId:transferOrder.orderFacilityExternalId]"/>

                <!-- Get the completed items, this is to create the history for all the items. -->
                <!-- NOTE For Cancelled items in Completed order, it will be treated as not shipped and not received and
                    history will get created -->
                <entity-find entity-name="co.hotwax.netsuite.TransferOrderItemAndHistory" list="completedOrderItemsList">
                    <econdition field-name="orderId" from="transferOrder.orderId"/>
                </entity-find>

                <!-- Get the items which are shipped and may be under or over-received -->
                <entity-find entity-name="co.hotwax.shipment.TransferOrderItemShipmentSummary" list="shippedOrderItemsList">
                    <econdition field-name="orderId" from="transferOrder.orderId"/>
                    <econdition field-name="itemStatusId" value="ITEM_COMPLETED"/>
                    <having-econditions>
                        <econdition field-name="qtyAvailableToReceive" operator="greater-equals" value="0"/>
                    </having-econditions>
                </entity-find>

                <!-- Prepare the over received items for the feed -->
                <set field="overReceivedItemList" from="shippedOrderItemsList.findAll { it.qtyAvailableToReceive == 0 }"/>
                <!-- Get unique orderId and orderItemSeqId to prevent unnecessary loop for multiple receipts for the same order item -->
                <set field="uniqueOverReceivedToItems" from="overReceivedItemList.collect{ [orderId: it.orderId, orderItemSeqId: it.orderItemSeqId, orderItemExternalId: it.orderItemExternalId, productId: it.productId] }.unique()"/>

                <set field="overReceivedItems" from="[]"/>
                <!-- Separate list to include specific comment for each item history creation -->
                <set field="itemsToCreateHistory" from="[]"/>
                <!-- This may be completely received or over-received -->
                <iterate list="uniqueOverReceivedToItems" entry="uniqueOverReceivedToItem">
                    <!-- Get total Shipped quantity for the item -->
                    <entity-find entity-name="org.apache.ofbiz.order.order.OrderShipment" list="orderShipmentList">
                        <econdition field-name="orderId" from="uniqueOverReceivedToItem.orderId"/>
                        <econdition field-name="orderItemSeqId" from="uniqueOverReceivedToItem.orderItemSeqId"/>
                        <select-field field-name="orderId,orderItemSeqId,quantity"/>
                    </entity-find>

                    <!-- Get total Received Quantity for the item -->
                    <entity-find entity-name="co.hotwax.shipment.ShipmentReceiptSummary" list="shipmentReceiptList">
                        <econdition field-name="orderId" from="uniqueOverReceivedToItem.orderId"/>
                        <econdition field-name="orderItemSeqId" from="uniqueOverReceivedToItem.orderItemSeqId"/>
                        <select-field field-name="orderId,orderItemSeqId,quantityAccepted"/>
                    </entity-find>

                    <set field="totalShippedQty" from="orderShipmentList*.quantity.sum()"/>
                    <set field="totalReceivedQty" from="shipmentReceiptList?.first?.quantityAccepted"/>

                    <if condition="totalReceivedQty &gt; totalShippedQty"><then>
                        <!-- Get NetSuite Product ID for each item -->
                        <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                            <econdition field-name="productId" from="uniqueOverReceivedToItem.productId"/>
                            <econdition field-name="goodIdentificationTypeId" value="NETSUITE_PRODUCT_ID"/>
                            <date-filter/>
                        </entity-find>

                        <set field="overReceivedQty" from="totalReceivedQty.subtract(totalShippedQty)"/>
                        <set field="overReceivedItemMap" from="[orderItemSeqId:uniqueOverReceivedToItem.orderItemSeqId, orderLineId:uniqueOverReceivedToItem.orderItemExternalId, itemId:goodIdentificationList?.first?.idValue, overReceivedQty:overReceivedQty]"/>
                        <script>overReceivedItems.add(overReceivedItemMap)</script>
                        <script>itemsToCreateHistory.add(overReceivedItemMap + [orderId:transferOrder.orderId, comment:'Transfer Order Item over received, sent as part of Transfer Order Reconciliation Feed'])</script>
                        <set field="isFileEmpty" from="false"/>
                    </then><else-if condition="totalReceivedQty == totalShippedQty">
                        <script>itemsToCreateHistory.add(uniqueOverReceivedToItem + [comment:'Transfer Order Item fully received, not sent as part of Transfer Order Reconciliation Feed'])</script>
                    </else-if>
                    </if>
                </iterate>

                <!-- Prepare the under received items for the feed shipment wise -->
                <set field="underReceivedShipmentItemList" from="shippedOrderItemsList.findAll { it.qtyAvailableToReceive &gt; 0 }"/>
                <set field="underReceivedShipments" from="[]"/>
                <set field="shipmentIds" from="new HashSet(underReceivedShipmentItemList*.shipmentId)"/>

                <!-- Get unique orderId and orderItemSeqId to create history of the items -->
                <set field="uniqueUnderReceivedToItems" from="underReceivedShipmentItemList.collect{ [orderId: it.orderId, orderItemSeqId: it.orderItemSeqId] }.unique()"/>
                <set field="uniqueUnderReceivedToItems*.comment" value="Transfer Order Item under received, sent as part of Transfer Order Reconciliation Feed"/>
                <script>itemsToCreateHistory.addAll(uniqueUnderReceivedToItems)</script>

                <iterate list="shipmentIds" entry="shipmentId">
                    <set field="items" from="[]"/>
                    <!-- Set Transfer Order Shipment level details -->
                    <set field="shipmentMap" from="[hcShipmentId:shipmentId]"/>

                    <set field="itemsList" from="underReceivedShipmentItemList.findAll{ it.shipmentId == shipmentId }"/>
                    <set field="shipmentMap.fulfillmentId" from="itemsList[0].shipmentExternalId"/>

                    <iterate list="itemsList" entry="underReceivedShipmentItem">
                        <!-- Get NetSuite Product ID for each item -->
                        <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                            <econdition field-name="productId" from="underReceivedShipmentItem.productId"/>
                            <econdition field-name="goodIdentificationTypeId" value="NETSUITE_PRODUCT_ID"/>
                            <date-filter/>
                        </entity-find>

                        <!-- Set Shipment Receipt Item level details -->
                        <set field="shipmentReceiptItemMap" from="[
                            orderItemSeqId:underReceivedShipmentItem.orderItemSeqId,
                            lineId:underReceivedShipmentItem.shipmentItemExternalId,
                            orderLineId:underReceivedShipmentItem.orderItemExternalId,
                            itemId:goodIdentificationList?.first?.idValue,
                            underReceivedQty:-(underReceivedShipmentItem.qtyAvailableToReceive)]"/>
                        <script>items.add(shipmentReceiptItemMap)</script>
                    </iterate>

                    <set field="shipmentMap.items" from="items"/>
                    <script>underReceivedShipments.add(shipmentMap)</script>
                    <set field="isFileEmpty" from="false"/>
                </iterate>

                <!-- Preparing the completed items which are not shipped, need to check the receipts and include in over received or not -->
                <!-- For the completedNotShippedItems items,
                       This could be case of "not shipped not received" or "not shipped but received",
                       for the first one, we need to ignore the item as it will be included in the Close TransferOrderItemsFeed ,
                       for the second one, we need to include the item in overReceivedItems list -->
                <set field="uniqueTransferOrderShippedItemIds" from="new HashSet(shippedOrderItemsList*.orderItemSeqId)"/>
                <set field="completedNotShippedItems" from="completedOrderItemsList.findAll { !(it.orderItemSeqId in uniqueTransferOrderShippedItemIds) }"/>
                <iterate list="completedNotShippedItems" entry="completedNotShippedItem">
                    <!-- Check if received quantity -->
                    <!-- Get total Received Quantity for the item -->
                    <entity-find entity-name="co.hotwax.shipment.ShipmentReceiptSummary" list="shipmentReceiptList">
                        <econdition field-name="orderId" from="transferOrder.orderId"/>
                        <econdition field-name="orderItemSeqId" from="completedNotShippedItem.orderItemSeqId"/>
                        <select-field field-name="orderId,orderItemSeqId,quantityAccepted"/>
                    </entity-find>
                    <set field="totalReceivedQty" from="shipmentReceiptList?.first?.quantityAccepted"/>

                    <if condition="totalReceivedQty &gt; 0"><then>
                        <!-- Put it in over-received items -->
                        <!-- Get NetSuite Product ID for each item -->
                        <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                            <econdition field-name="productId" from="completedNotShippedItem.productId"/>
                            <econdition field-name="goodIdentificationTypeId" value="NETSUITE_PRODUCT_ID"/>
                            <date-filter/>
                        </entity-find>

                        <set field="orderItemMap" from="[orderItemSeqId:completedNotShippedItem.orderItemSeqId, orderLineId:completedNotShippedItem.orderItemExternalId, itemId:goodIdentificationList?.first?.idValue, overReceivedQty:totalReceivedQty]"/>
                        <script>overReceivedItems.add(orderItemMap)</script>
                        <script>itemsToCreateHistory.add(orderItemMap + [orderId:transferOrder.orderId, comment:'Transfer Order Item not shipped but received, sent as part of Transfer Order Reconciliation Feed'])</script>
                        <set field="isFileEmpty" from="false"/>
                    </then><else>
                        <script>itemsToCreateHistory.add([orderId:transferOrder.orderId, orderItemSeqId:completedNotShippedItem.orderItemSeqId, comment:'Transfer Order Item not shipped and not received, not sent as part of Transfer Order Reconciliation Feed'])</script>
                        <set field="isFileEmpty" from="false"/>
                    </else>
                    </if>
                </iterate>

                <!-- Create History for the items -->
                <iterate list="itemsToCreateHistory" entry="itemToCreateHistory">
                    <service-call name="create#co.hotwax.integration.order.TransferOrderItemHistory"
                            in-map="[orderId:itemToCreateHistory.orderId, orderItemSeqId:itemToCreateHistory.orderItemSeqId,
                            createdDate:nowTimestamp, comments:itemToCreateHistory.comment]"/>
                </iterate>

                <set field="transferOrderMap.overReceivedItems" from="overReceivedItems"/>
                <set field="transferOrderMap.underReceivedShipments" from="underReceivedShipments"/>

                <!-- This is done to skip creating the order level map if fully received TO -->
                <if condition="overReceivedItems.isEmpty() &amp;&amp; underReceivedShipments.isEmpty()">
                    <continue/>
                </if>

                <script>
                    new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, transferOrderMap)
                </script>
            </iterate>
            <script>
                            jGenerator.writeEndArray()
                        }
                    } catch (IOException e) {
                        logger.info("Error preparing transfer order reconciliation Feed file", e)
                    }
                }
            </script>

            <!-- Call queue#SystemMessage that will save the json file path in messageText and
            send the file to sftp using send service configured in SystemMessageType -->
            <if condition="!isFileEmpty">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                        in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                        messageText:jsonFilePathRef]" out-map="toReconciliationFeedSysMsgOut"/>
            </if>

            <return message="Completed the Transfer Order Completed Items Reconciliation Feed file at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${toReconciliationFeedSysMsgOut?.systemMessageId}"/>
        </actions>
    </service>
</services>
